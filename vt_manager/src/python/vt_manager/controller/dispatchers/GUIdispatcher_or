from django.core.urlresolvers import reverse
from django.forms.models import modelformset_factory
from django.shortcuts import get_object_or_404
from django.http import HttpResponseRedirect
from django.views.generic import simple
from vt_manager.common.utils.views import generic_crud
from vt_manager.common.messaging.models import DatedMessage
from vt_manager.models import VTServer
from django.views.generic import list_detail, create_update, simple
from vt_manager.models import *
from vt_manager.communication.utils.XmlUtils import XmlHelper
from vt_manager.controller.dispatchers.ProvisioningDispatcher import *
from vt_manager.controller.utils.Translator import *
import uuid
import time
import logging

def userIsIslandManager(request):

    if (not request.user.is_superuser):
        
        return simple.direct_to_template(request,
                            template = 'not_admin.html',
                            extra_context = {'user':request.user},
                        )

def servers_crud(request, server_id=None):
    """Show a page for the user to add/edit an  VTServer """

    if (not request.user.is_superuser):
        
        return simple.direct_to_template(request,
                            template = 'not_admin.html',
                            extra_context = {'user':request.user},
                        )

    return server_generic_crud(
        request,
        obj_id=server_id,
        model=VTServer,
        template_object_name="server",
        template="servers/servers_crud.html",
        redirect = lambda inst: '/servers/admin/'
    )

from django.shortcuts import get_object_or_404
from django.views.generic.create_update import get_model_and_form_class
from django.views.generic import simple
from django.http import HttpResponseRedirect, HttpResponseNotAllowed
from vt_manager.common.messaging.models import DatedMessage

def server_generic_crud(request, obj_id, model, template, redirect,
                 extra_context={}, form_class=None,
                 template_object_name="object", pre_save=None,
                 post_save=None, success_msg=None):
    """
    Generic way to create/update a bit more advanced than the django's generic
    views. The context will contain the form as C{form}, the object when
    updating as the value in C{template_object_name} which defaults to
    "object", and anything specified in C{extra_context}.
    
    @param request: The request object
    @param obj_id: The object's id to update or None if creating an object
    @param model: The model class
    @param template: the name of the template to use
    @param redirect: callable that takes the created/saved instance as argument
        and returns a URL to redirect to.
    @keyword extra_context: dict of fields to add to the template context.
    @keyword form_class: the form class to use for the object (ModelForm subclass)
    @keyword template_object_name: name of the object field in the template
        context. This is only available when updating.
    @keyword pre_save: function to call before saving the object instantiated
        from the form. Called with arguments (C{instance}, C{created}).
    @keyword post_save: function to call after saving the object instantiated
        from the form but before calling m2m_save() on it. Called with argument
        (C{instance}, C{created}).
    @keyword success_msg: callable that should take instance as parameter and
        return a string to be put in a success DatedMessage and sent to the
        user on success. 
    """
    
    model, form_class = get_model_and_form_class(model, form_class)

    if obj_id != None:
        instance = get_object_or_404(model, pk=obj_id)
    else:
        instance = None
        
    if request.method == "GET":
        form = form_class(instance=instance)
    elif request.method == "POST":
        form = form_class(request.POST, instance=instance)
        if form.is_valid():
            instance = form.save(commit=False)
            if pre_save: pre_save(instance, obj_id == None)
            instance.save()
            if post_save: post_save(instance, obj_id == None)
            form.save_m2m()
            if success_msg:
                DatedMessage.objects.post_message_to_user(
                    success_msg(instance), request.user,
                    msg_type=DatedMessage.TYPE_SUCCESS)
            return HttpResponseRedirect(redirect(instance))
    else:
        return HttpResponseNotAllowed("GET", "POST")

    context = {"form": form}
    context.update(extra_context)
    if obj_id != None: context[template_object_name] = instance

    return simple.direct_to_template(
        request,
        template=template,
        extra_context=context,
        form=form,
    )


    
def admin_servers(request):
    
    if (not request.user.is_superuser):
        
        return simple.direct_to_template(request,
                            template = 'not_admin.html',
                            extra_context = {'user':request.user},
                        ) 

    servers_ids = VTServer.objects.all()

    return simple.direct_to_template(
        request, template="servers/admin_servers.html",
        extra_context={"servers_ids": servers_ids})

def delete_server(request, server_id):
    """
    Display a confirmation page (NOT IMLPEMENTED YET: then stop all slices) and delete the aggregate.
    """
    if (not request.user.is_superuser):
        
        return simple.direct_to_template(request,
                            template = 'not_admin.html',
                            extra_context = {'user':request.user},
                        )
 
    next = reverse("admin_servers")
    server = get_object_or_404(VTServer, id=server_id)
    req = create_update.delete_object(
        request,
        model=VTServer,
        post_delete_redirect=next,
        object_id=server_id,
        extra_context={"next": next},
        template_name="servers/delete_server.html",
    )
    return req

def action_vm(request, server_id, vm_id, action):

    if (not request.user.is_superuser):
        
        return simple.direct_to_template(request,
                            template = 'not_admin.html',
                            extra_context = {'user':request.user},
                        )

    if(action == 'list'):
          
        return simple.direct_to_template(
        request, template="servers/list_vm.html",
        extra_context={"vm": VM.objects.get(id = vm_id)})

    elif(action == 'check_status'):
        #check_state
        return simple.direct_to_template(
        request, template="servers/list_vm.html",
        extra_context={"vm": VM.objects.get(id = vm_id)})

    else:
        vm = VM.objects.get(id = vm_id)
        rspec = XmlHelper.getSimpleActionSpecificQuery(action)
        Translator.PopulateNewAction(rspec.query.provisioning.action[0], vm)
        ProvisioningDispatcher.processProvisioning(rspec.query.provisioning)
    
        #TODO: Very ugly way to wait until the responses arrived and the state of teh VM is refreshed without having to reload the page
        time.sleep(3)
        return HttpResponseRedirect(reverse('edit_server', args = [server_id]))
